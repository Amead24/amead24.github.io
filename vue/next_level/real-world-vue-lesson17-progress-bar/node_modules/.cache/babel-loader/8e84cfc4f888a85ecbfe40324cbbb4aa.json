{"remainingRequest":"/home/tony/library/vue/next_level/real-world-vue-lesson17-progress-bar/node_modules/babel-loader/lib/index.js!/home/tony/library/vue/next_level/real-world-vue-lesson17-progress-bar/node_modules/eslint-loader/index.js??ref--13-0!/home/tony/library/vue/next_level/real-world-vue-lesson17-progress-bar/src/services/EventService.js","dependencies":[{"path":"/home/tony/library/vue/next_level/real-world-vue-lesson17-progress-bar/src/services/EventService.js","mtime":1585267274555},{"path":"/home/tony/library/vue/next_level/real-world-vue-lesson17-progress-bar/node_modules/cache-loader/dist/cjs.js","mtime":1585267166739},{"path":"/home/tony/library/vue/next_level/real-world-vue-lesson17-progress-bar/node_modules/babel-loader/lib/index.js","mtime":1529635966000},{"path":"/home/tony/library/vue/next_level/real-world-vue-lesson17-progress-bar/node_modules/eslint-loader/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.array.iterator\";\nimport \"core-js/modules/es6.promise\";\nimport \"core-js/modules/es7.promise.finally\";\nimport axios from 'axios';\nimport NProgress from 'nprogress';\nvar apiClient = axios.create({\n  baseURL: \"http://localhost:3000\",\n  withCredentials: false,\n  // This is the default\n  headers: {\n    Accept: 'application/json',\n    'Content-Type': 'application/json'\n  }\n});\n/*\n * This solution doesn't scale if multiple requests were pending,\n * and so you'd want to centralize that counter.  One suggestion surrounds\n * creating a vuex state module that gets incremented and decremented with \n * every api call, with computed properties that trigger .start() & .done()\n */\n\n/* \n * Reasons for interceptors:\n * 1. on request to set authorization tokens\n * 2. on response to format or filter data\n * 3. on response catch 401 not authorized\n */\n\napiClient.interceptors.request.use(function (config) {\n  NProgress.start();\n  return config;\n});\napiClient.interceptors.response.use(function (response) {\n  NProgress.done();\n  return response;\n});\nexport default {\n  getEvents: function getEvents(perPage, page) {\n    return apiClient.get('/events?_limit=' + perPage + '&_page=' + page);\n  },\n  getEvent: function getEvent(id) {\n    return apiClient.get('/events/' + id);\n  },\n  postEvent: function postEvent(event) {\n    return apiClient.post('/events', event);\n  }\n};",{"version":3,"sources":["src/services/EventService.js"],"names":["axios","NProgress","apiClient","create","baseURL","withCredentials","headers","Accept","interceptors","request","use","start","config","response","done","getEvents","perPage","page","get","getEvent","id","postEvent","event","post"],"mappings":";;;AAAA,OAAOA,KAAP,MAAkB,OAAlB;AACA,OAAOC,SAAP,MAAsB,WAAtB;AAEA,IAAMC,YAAYF,MAAMG,MAAN,CAAa;AAC7BC,kCAD6B;AAE7BC,mBAAiB,KAFY;AAEL;AACxBC,WAAS;AACPC,YAAQ,kBADD;AAEP,oBAAgB;AAFT;AAHoB,CAAb,CAAlB;AASA;;;;;;;AAQA;;;;;;;AAOAL,UAAUM,YAAV,CAAuBC,OAAvB,CAA+BC,GAA/B,CAAmC,kBAAU;AAC3CT,YAAUU,KAAV;AACA,SAAOC,MAAP;AACD,CAHD;AAKAV,UAAUM,YAAV,CAAuBK,QAAvB,CAAgCH,GAAhC,CAAoC,oBAAY;AAC9CT,YAAUa,IAAV;AACA,SAAOD,QAAP;AACD,CAHD;AAMA,eAAe;AACbE,WADa,qBACHC,OADG,EACMC,IADN,EACY;AACvB,WAAOf,UAAUgB,GAAV,CAAc,oBAAoBF,OAApB,GAA8B,SAA9B,GAA0CC,IAAxD,CAAP;AACD,GAHY;AAIbE,UAJa,oBAIJC,EAJI,EAIA;AACX,WAAOlB,UAAUgB,GAAV,CAAc,aAAaE,EAA3B,CAAP;AACD,GANY;AAObC,WAPa,qBAOHC,KAPG,EAOI;AACf,WAAOpB,UAAUqB,IAAV,CAAe,SAAf,EAA0BD,KAA1B,CAAP;AACD;AATY,CAAf","sourceRoot":"/home/tony/library/vue/next_level/real-world-vue-lesson17-progress-bar","sourcesContent":["import axios from 'axios'\nimport NProgress from 'nprogress'\n\nconst apiClient = axios.create({\n  baseURL: `http://localhost:3000`,\n  withCredentials: false, // This is the default\n  headers: {\n    Accept: 'application/json',\n    'Content-Type': 'application/json'\n  }\n})\n\n/*\n * This solution doesn't scale if multiple requests were pending,\n * and so you'd want to centralize that counter.  One suggestion surrounds\n * creating a vuex state module that gets incremented and decremented with \n * every api call, with computed properties that trigger .start() & .done()\n */\n    \n\n/* \n * Reasons for interceptors:\n * 1. on request to set authorization tokens\n * 2. on response to format or filter data\n * 3. on response catch 401 not authorized\n */\n\napiClient.interceptors.request.use(config => {\n  NProgress.start()\n  return config\n})\n\napiClient.interceptors.response.use(response => {\n  NProgress.done()\n  return response\n})\n\n\nexport default {\n  getEvents(perPage, page) {\n    return apiClient.get('/events?_limit=' + perPage + '&_page=' + page)\n  },\n  getEvent(id) {\n    return apiClient.get('/events/' + id)\n  },\n  postEvent(event) {\n    return apiClient.post('/events', event)\n  }\n}\n"]}]}